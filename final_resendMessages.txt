private void resendMessages(Message receivedMessage, int beginSeqNo, int endSeqNo)
        throws IOException, InvalidMessage, FieldNotFound {

    final ArrayList<String> messages = new ArrayList<>();
    try {
        state.get(beginSeqNo, endSeqNo, messages);
    } catch (final IOException e) {
        if (forceResendWhenCorruptedStore) {
            LOG.error("Cannot read messages from stores, resend HeartBeats", e);
            for (int i = beginSeqNo; i < endSeqNo; i++) {
                final Message heartbeat = messageFactory.create(sessionID.getBeginString(),
                        MsgType.HEARTBEAT);
                initializeHeader(heartbeat.getHeader());
                heartbeat.getHeader().setInt(MsgSeqNum.FIELD, i);
                messages.add(heartbeat.toString());
            }
        } else {
            throw e;
        }
    }

    int msgSeqNum = 0;
    int begin = 0;
    int current = beginSeqNo;
    boolean appMessageJustSent = false;
    boolean sendFailed = false;

    // Process each message in the requested range
    for (final String message : messages) {
        // Skip processing more messages if a send has failed
        if (sendFailed) {
            break;
        }
        
        appMessageJustSent = false;
        final Message msg;
        try {
            // QFJ-626
            msg = parseMessage(message);
            msgSeqNum = msg.getHeader().getInt(MsgSeqNum.FIELD);
        } catch (final Exception e) {
            getLog().onErrorEvent(
                    "Error handling ResendRequest: failed to parse message (" + e.getMessage()
                    + "): " + message);
            // Note: a SequenceReset message will be generated to fill the gap
            continue;
        }

        if ((current != msgSeqNum) && begin == 0) {
            begin = current;
        }

        final String msgType = msg.getHeader().getString(MsgType.FIELD);

        if (MessageUtils.isAdminMessage(msgType) && !forceResendWhenCorruptedStore) {
            if (begin == 0) {
                begin = msgSeqNum;
            }
        } else {
            initializeResendFields(msg);
            if (resendApproved(msg)) {
                // Only generate sequence reset if send hasn't failed
                if (begin != 0 && !sendFailed) {
                    // Use a custom method that respects the sendFailed flag
                    if (!generateSequenceResetIfNotFailed(receivedMessage, begin, msgSeqNum, sendFailed)) {
                        sendFailed = true;
                        break;
                    }
                }
                
                // Only attempt to send if previous sends haven't failed
                if (!sendFailed) {
                    getLog().onEvent("Resending message: " + msgSeqNum);
                    if (!send(msg.toString())) {
                        getLog().onErrorEvent("Failed to send resend message: " + msgSeqNum + ", aborting resend process");
                        sendFailed = true;
                        break; // Exit the loop immediately
                    } else {
                        begin = 0;
                        appMessageJustSent = true;
                    }
                }
            } else {
                if (begin == 0) {
                    begin = msgSeqNum;
                }
            }
        }
        current = msgSeqNum + 1;
    }

    // Skip all remaining processing if a send failed
    // This includes sequence reset generation and any other operations
    if (sendFailed) {
        return;
    }

    int newBegin = beginSeqNo;
    if (appMessageJustSent) {
        newBegin = msgSeqNum + 1;
    }
    
    // Only proceed with sequence reset generation if no send has failed
    if (enableNextExpectedMsgSeqNum) {
        if (begin != 0) {
            if (!generateSequenceResetIfNotFailed(receivedMessage, begin, msgSeqNum + 1, sendFailed)) {
                return;
            }
        } else {
            /*
             * I've added an else here as I managed to fail this without it in a unit test, however the unit test data
             * may not have been realistic to production on the other hand.
             * Apart from the else
             */
            if (!generateSequenceResetIfNeededAndNotFailed(receivedMessage, newBegin, endSeqNo, msgSeqNum, sendFailed)) {
                return;
            }
        }
    } else {
        if (begin != 0) {
            if (!generateSequenceResetIfNotFailed(receivedMessage, begin, msgSeqNum + 1, sendFailed)) {
                return;
            }
        }
        if (!generateSequenceResetIfNeededAndNotFailed(receivedMessage, newBegin, endSeqNo, msgSeqNum, sendFailed)) {
            return;
        }
    }
}

// Helper method to generate sequence reset only if send hasn't failed
private boolean generateSequenceResetIfNotFailed(Message receivedMessage, int beginSeqNo, int endSeqNo, boolean sendFailed) 
        throws FieldNotFound {
    if (sendFailed) {
        return false;
    }
    generateSequenceReset(receivedMessage, beginSeqNo, endSeqNo);
    return true;
}

// Helper method to generate sequence reset if needed and send hasn't failed
private boolean generateSequenceResetIfNeededAndNotFailed(Message receivedMessage, int beginSeqNo, int endSeqNo, 
        int msgSeqNum, boolean sendFailed) throws IOException, InvalidMessage, FieldNotFound {
    if (sendFailed) {
        return false;
    }
    generateSequenceResetIfNeeded(receivedMessage, beginSeqNo, endSeqNo, msgSeqNum);
    return true;
}